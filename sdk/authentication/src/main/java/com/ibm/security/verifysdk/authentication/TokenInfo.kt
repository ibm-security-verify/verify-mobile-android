//
// Copyright contributors to the IBM Security Verify Authentication SDK for Android project
//
package com.ibm.security.verifysdk.authentication

import android.os.Parcel
import android.os.Parcelable
import com.ibm.security.verifysdk.core.extension.toJsonElement
import com.ibm.security.verifysdk.core.extension.toJsonObject
import com.ibm.security.verifysdk.core.extension.toNumberOrNull
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlinx.parcelize.Parceler
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encodeToString
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonDecoder
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonEncoder
import kotlinx.serialization.json.JsonNames
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.intOrNull
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.longOrNull
import org.json.JSONObject
import java.util.Objects
import java.util.stream.Collectors

/**
 * The authorization server issues an access token and optional refresh token.  In addition, it
 * provides the token type and other properties supporting the access token.
 *
 * @since 3.0.0
 */
@Parcelize
@Serializable(with = TokenInfoSerializer::class)
@OptIn(ExperimentalSerializationApi::class)
data class TokenInfo constructor(

    /**
     * The access token generated by the authorization server.
     */
    @JsonNames("access_token")
    val accessToken: String = "",

    /**
     * The refresh token, which can be used to obtain new access tokens using the same
     * authorization grant.
     */
    @JsonNames("refresh_token")
    val refreshToken: String = "",

    /**
     * The date and time when the access token was created.
     */
    @JsonNames("created_on")
    val createdOn: kotlinx.datetime.Instant = Clock.System.now(),

    /**
     *  The lifetime in seconds of the access token.
     *
     *  For example, the value "3600" denotes that the access token will expire in one hour from
     *  the time the response was generated.
     */
    @JsonNames("expires_in")
    val expiresIn: Int = 0,

    /**
     * The date and time when the access token expires.
     */
    @JsonNames("expires_on")
    val expiresOn: Instant = Clock.System.now(),

    /**
     * The scope of the access token.
     *
     * If the scope the user granted is identical to the scope the app requested, this parameter
     * is optional. If the granted scope is different from the requested scope, such as if the
     * user modified the scope, then this parameter is required.
     */
    @JsonNames("scope")
    val scope: String = "",

    /**
     * Typically "Bearer" when present. Otherwise, another `tokenType` value that the client
     * has negotiated with the authorization server.
     */
    @JsonNames("token_type")
    val tokenType: String = "",

    /**
     * Additional data parameters returned from the token server.
     */
    val additionalData: Map<String, Any>
) : Parcelable {

    internal companion object : Parceler<TokenInfo> {

        override fun create(parcel: Parcel): TokenInfo {
            val accessToken = parcel.readString() ?: ""
            val refreshToken = parcel.readString() ?: ""
            val createdOn = Instant.fromEpochSeconds(parcel.readLong())
            val expiresIn = parcel.readInt()
            val expiresOn = Instant.fromEpochSeconds(parcel.readLong())
            val scope = parcel.readString() ?: ""
            val tokenType = parcel.readString() ?: ""
            val additionalData = HashMap<String, Any>()

            parcel.readMap(additionalData, Map::class.java.classLoader)

            return TokenInfo(
                accessToken,
                refreshToken,
                createdOn,
                expiresIn,
                expiresOn,
                scope,
                tokenType,
                additionalData
            )
        }

        override fun TokenInfo.write(parcel: Parcel, flags: Int) {
            parcel.writeString(accessToken)
            parcel.writeString(refreshToken)
            parcel.writeLong(createdOn.epochSeconds)
            parcel.writeInt(expiresIn)
            parcel.writeLong(expiresOn.epochSeconds)
            parcel.writeString(scope)
            parcel.writeString(tokenType)
            parcel.writeMap(additionalData)
        }
    }

    /**
     * Returns a [JSONObject] representation of the token.
     *
     * @param withReadableTimestamps  flag to indicate whether the timestamp should be
     *              should be in a human readable format.
     */
    fun toJson(withReadableTimestamps: Boolean = false): JSONObject {

        val jsonString = JSONObject(Json.encodeToString(this))
        if (withReadableTimestamps) {
            jsonString.put(TokenInfoSerializer.CREATED_ON, createdOn.toString())
            jsonString.put(TokenInfoSerializer.EXPIRES_ON, expiresOn.toString())
        }

        return jsonString
    }
}

/**
 *
 * Returns `true` if a certain percentage of the lifetime has elapsed since was created. The
 * default for the lifetime is 90%.
 *
 * @param threshold  elapsed lifetime in % when the token should be refreshed
 */
@Suppress("BooleanMethodIsAlwaysInverted")
fun TokenInfo.shouldRefresh(threshold: Int = 90): Boolean {
    return ((System.currentTimeMillis() / 1000) > createdOn.epochSeconds +
            (expiresOn.epochSeconds - createdOn.epochSeconds) * threshold / 100)
}

internal object TokenInfoSerializer : KSerializer<TokenInfo> {

    private const val ACCESS_TOKEN = "accessToken"
    private const val REFRESH_TOKEN = "refreshToken"
    internal const val CREATED_ON = "createdOn"
    private const val EXPIRES_IN = "expiresIn"
    internal const val EXPIRES_ON = "expiresOn"
    private const val SCOPE = "scope"
    private const val TOKEN_TYPE = "tokenType"

    private val knownKeys = setOf(
        "access_token",
        "accessToken",
        "created_on",
        "createdOn",
        "expires_in",
        "expires_on",
        "expiresIn",
        "expiresOn",
        "refresh_token",
        "refreshToken",
        "scope",
        "token_type",
        "tokenType",
        "version",  // ignored as attribute is not used
        "metadata"  // ignored as key is for the Metadata class and handled there
    )

    private val mapSerializerStringToJsonElement =
        MapSerializer(String.serializer(), JsonElement.serializer())

    override val descriptor: SerialDescriptor = mapSerializerStringToJsonElement.descriptor

    override fun deserialize(decoder: Decoder): TokenInfo {
        require(decoder is JsonDecoder)
        val decoderMap = decoder.decodeSerializableValue(mapSerializerStringToJsonElement)

        val accessToken = listOf(ACCESS_TOKEN, "access_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val refreshToken = listOf(REFRESH_TOKEN, "refresh_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val expiresIn = listOf(EXPIRES_IN, "expires_in").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.intOrNull ?: 0

        val createdOn = listOf(CREATED_ON, "created_on").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.longOrNull
            ?: (System.currentTimeMillis() / 1000)

        val expiresOn = listOf(EXPIRES_ON, "expires_on").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.longOrNull
            ?: (createdOn + expiresIn)

        val scope = listOf(SCOPE).stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val tokenType = listOf(TOKEN_TYPE, "token_type").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty().takeIf { it.isNotEmpty() } ?: "Bearer"

        val additionalData = decoderMap
            .filter { (key, _) -> !knownKeys.contains(key) }
            .mapValues { (_, value) -> deserializeJsonElement(value.jsonPrimitive) }

        return TokenInfo(
            accessToken, refreshToken, Instant.fromEpochSeconds(createdOn), expiresIn,
            Instant.fromEpochSeconds(expiresOn), scope, tokenType, additionalData
        )
    }

    private fun deserializeJsonElement(element: JsonPrimitive): Any {

        if (element is JsonNull) {
            return JsonNull
        }

        if (element.isString) {
            return element.content
        }

        element.content.lowercase() // toBooleanStrictOrNull() is case sensitive
            .toBooleanStrictOrNull()
            ?.let {
                return it
            } ?: element.content.toNumberOrNull()?.let {
            return it
        } ?: throw IllegalArgumentException("Unknown type for JSON value: ${element.content}")
    }

    override fun serialize(encoder: Encoder, value: TokenInfo) {
        require(encoder is JsonEncoder)
        val map: MutableMap<String, JsonElement> = mutableMapOf()

        map[ACCESS_TOKEN] = value.accessToken.toJsonElement()
        map[REFRESH_TOKEN] = value.refreshToken.toJsonElement()
        map[CREATED_ON] = value.createdOn.epochSeconds.toJsonElement()
        map[EXPIRES_IN] = value.expiresIn.toJsonElement()
        map[EXPIRES_ON] = value.expiresOn.epochSeconds.toJsonElement()
        map[SCOPE] = value.scope.toJsonElement()
        map[TOKEN_TYPE] = value.tokenType.toJsonElement()
        map.putAll(value.additionalData.toJsonObject())

        encoder.encodeSerializableValue(mapSerializerStringToJsonElement, map)
    }
}