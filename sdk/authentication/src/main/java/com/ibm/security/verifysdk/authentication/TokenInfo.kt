//
// Copyright contributors to the IBM Security Verify Authentication SDK for Android project
//
package com.ibm.security.verifysdk.authentication

import android.os.Parcel
import android.os.Parcelable
import com.ibm.security.verifysdk.core.toJsonElement
import com.ibm.security.verifysdk.core.toJsonObject
import com.ibm.security.verifysdk.core.toNumberOrNull
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlinx.parcelize.Parceler
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encodeToString
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.*
import org.json.JSONObject
import java.util.*
import java.util.stream.Collectors

/**
 * The authorization server issues an access token and optional refresh token.  In addition, it
 * provides the token type and other properties supporting the access token.
 *
 * @since 3.0.0
 */
@Parcelize
@Serializable(with = TokenInfoSerializer::class)
data class TokenInfo @OptIn(ExperimentalSerializationApi::class) constructor(

    /**
     * The access token generated by the authorization server.
     */
    @JsonNames("access_token")
    val accessToken: String = "",

    /**
     * The refresh token, which can be used to obtain new access tokens using the same
     * authorization grant.
     */
    @JsonNames("refresh_token")
    val refreshToken: String = "",

    /**
     * The date and time when the access token was created.
     */
    @JsonNames("created_on")
    val createdOn: Instant = Clock.System.now(),

    /**
     *  The lifetime in seconds of the access token.
     *
     *  For example, the value "3600" denotes that the access token will expire in one hour from
     *  the time the response was generated.
     */
    @JsonNames("expires_in")
    val expiresIn: Int = 0,

    /**
     * The date and time when the access token expires.
     */
    @JsonNames("expires_on")
    val expiresOn: Instant = Clock.System.now(),

    /**
     * The scope of the access token.
     *
     * If the scope the user granted is identical to the scope the app requested, this parameter
     * is optional. If the granted scope is different from the requested scope, such as if the
     * user modified the scope, then this parameter is required.
     */
    @JsonNames("scope")
    val scope: String = "",

    /**
     * Typically "Bearer" when present. Otherwise, another `tokenType` value that the client
     * has negotiated with the authorization server.
     */
    @JsonNames("token_type")
    val tokenType: String = "",

    /**
     * Additional data parameters returned from the token server.
     */
    val additionalData: Map<String, Any>
) : Parcelable {

    internal companion object : Parceler<TokenInfo> {

        override fun create(parcel: Parcel): TokenInfo {
            val accessToken = parcel.readString() ?: ""
            val refreshToken = parcel.readString() ?: ""
            val createdOn = Instant.fromEpochSeconds(parcel.readLong())
            val expiresIn = parcel.readInt()
            val expiresOn = Instant.fromEpochSeconds(parcel.readLong())
            val scope = parcel.readString() ?: ""
            val tokenType = parcel.readString() ?: ""
            val additionalData = HashMap<String, Any>()

            parcel.readMap(additionalData, Map::class.java.classLoader)

            return TokenInfo(
                accessToken,
                refreshToken,
                createdOn,
                expiresIn,
                expiresOn,
                scope,
                tokenType,
                additionalData
            )
        }

        override fun TokenInfo.write(parcel: Parcel, flags: Int) {
            parcel.writeString(accessToken)
            parcel.writeString(refreshToken)
            parcel.writeLong(createdOn.epochSeconds)
            parcel.writeInt(expiresIn)
            parcel.writeLong(expiresOn.epochSeconds)
            parcel.writeString(scope)
            parcel.writeString(tokenType)
            parcel.writeMap(additionalData)
        }
    }

    /**
     * Returns a [JSONObject] representation of the token.
     *
     * @param withReadableTimestamps  flag to indicate whether the timestamp should be
     *              should be in a human readable format.
     */
    fun toJson(withReadableTimestamps: Boolean = false): JSONObject {

        val jsonString = JSONObject(Json.encodeToString(this))
        if (withReadableTimestamps) {
            jsonString.put(TokenInfoSerializer.CREATED_ON, createdOn.toString())
            jsonString.put(TokenInfoSerializer.EXPIRES_ON, expiresOn.toString())
        }

        return jsonString
    }

    /**
     *  Creates authorization header from token type and access token.  The authorization header
     *  is used in subsequent HTTP requests.
     *
     *  @return an authorization header.  For example: `Bearer ABC123`.
     */
    fun authorizationHeader(): String {
        return "$tokenType $accessToken"
    }
}

/**
 *
 * Returns `true` if a certain percentage of the lifetime has elapsed since was created. The
 * default for the lifetime is 90%.
 *
 * @param threshold  elapsed lifetime in % when the token should be refreshed
 */
@Suppress("BooleanMethodIsAlwaysInverted")
fun TokenInfo.shouldRefresh(threshold: Int = 90): Boolean {
    return ((System.currentTimeMillis() / 1000) > createdOn.epochSeconds +
            (expiresOn.epochSeconds - createdOn.epochSeconds) * threshold / 100)
}

internal object TokenInfoSerializer : KSerializer<TokenInfo> {

    private const val ACCESS_TOKEN = "accessToken"
    private const val REFRESH_TOKEN = "refreshToken"
    internal const val CREATED_ON = "createdOn"
    private const val EXPIRES_IN = "expiresIn"
    internal const val EXPIRES_ON = "expiresOn"
    private const val SCOPE = "scope"
    private const val TOKEN_TYPE = "tokenType"

    private val knownKeys = setOf(
        "access_token",
        "accessToken",
        "created_on",
        "createdOn",
        "expires_in",
        "expires_on",
        "expiresIn",
        "expiresOn",
        "refresh_token",
        "refreshToken",
        "scope",
        "token_type",
        "tokenType",
        "version",  // ignored as attribute is not used
        "metadata"  // ignored as key is for the Metadata class and handled there
    )

    private val mapSerializerStringToJsonElement =
        MapSerializer(String.serializer(), JsonElement.serializer())

    override val descriptor: SerialDescriptor = mapSerializerStringToJsonElement.descriptor

    override fun deserialize(decoder: Decoder): TokenInfo {
        require(decoder is JsonDecoder)
        val decoderMap = decoder.decodeSerializableValue(mapSerializerStringToJsonElement)

        val accessToken = listOf(ACCESS_TOKEN, "access_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val refreshToken = listOf(REFRESH_TOKEN, "refresh_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val expiresIn = listOf(EXPIRES_IN, "expires_in").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.intOrNull ?: 0

        val createdOn = listOf(CREATED_ON, "created_on").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.longOrNull
            ?: (System.currentTimeMillis() / 1000)

        val expiresOn = listOf(EXPIRES_ON, "expires_on").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.longOrNull
            ?: (createdOn + expiresIn)

        val scope = listOf(SCOPE).stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val tokenType = listOf(TOKEN_TYPE, "token_type").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty().takeIf { it.isNotEmpty() } ?: "Bearer"

        val additionalData = decoderMap
            .filter { (key, _) -> !knownKeys.contains(key) }
            .mapValues { (_, value) -> deserializeJsonElement(value.jsonPrimitive) }

        return TokenInfo(
            accessToken, refreshToken, Instant.fromEpochSeconds(createdOn), expiresIn,
            Instant.fromEpochSeconds(expiresOn), scope, tokenType, additionalData
        )
    }

    private fun deserializeJsonElement(element: JsonPrimitive): Any {

        if (element is JsonNull) {
            return JsonNull
        }

        if (element.isString) {
            return element.content
        }

        element.content.lowercase() // toBooleanStrictOrNull() is case sensitive
            .toBooleanStrictOrNull()
            ?.let {
                return it
            } ?: element.content.toNumberOrNull()?.let {
            return it
        } ?: throw IllegalArgumentException("Unknown type for JSON value: ${element.content}")
    }

    override fun serialize(encoder: Encoder, value: TokenInfo) {
        require(encoder is JsonEncoder)
        val map: MutableMap<String, JsonElement> = mutableMapOf()

        map[ACCESS_TOKEN] = value.accessToken.toJsonElement()
        map[REFRESH_TOKEN] = value.refreshToken.toJsonElement()
        map[CREATED_ON] = value.createdOn.epochSeconds.toJsonElement()
        map[EXPIRES_IN] = value.expiresIn.toJsonElement()
        map[EXPIRES_ON] = value.expiresOn.epochSeconds.toJsonElement()
        map[SCOPE] = value.scope.toJsonElement()
        map[TOKEN_TYPE] = value.tokenType.toJsonElement()
        map.putAll(value.additionalData.toJsonObject())

        encoder.encodeSerializableValue(mapSerializerStringToJsonElement, map)
    }
}